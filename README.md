# vue-component-holder

[![Version](https://img.shields.io/npm/v/vue-component-holder.svg)](https://www.npmjs.com/package/vue-component-holder)

# Navigation

- [Introduction](#Introduction)
- [Installation](#Installation)
- [Holdify](#Holdify)
- [Installation Options](#InstallationOptions)
- [APIs and Hooks](#APIs\sand\sHooks)

# Introduction

This plugin targets to combine the pros of synchronous and asynchronous component composing in vue. Synchronous composing is easy to use with a clear and explicit creating/mounting sequence. For example, in the parent's mounted() hook, it is ensured that all the child components have been created and mounted, so you can gather data/status/infomation from them. However, pure synchronous composing creates a single bundle file for your project, which could be potentially very large. Asynchronous composing solves this problem by partitioning the bundle file into some smaller chunks and loads them on demand, but it is fairly hard to handle asynchronous data and components. For example, the parent component has difficulty getting the exact moment when all the asynchronous children are ready. Another example is that it is hardly possible waiting for critical asynchronized data before/during creating components* because vue does not support asynchronized hooks. To solve such kind of problems, people have to use a lot of events between the parent and children which makes the code very verbose and hard to maintain, especially when the component tree is wide and deep.

This plugin introduces a component place-holder machanism. It places a holder component at the original place of each child component and manages the creation/mounting/destroy of child components by the plugin itself. Each of these child components becomes something called "mvm" (managed vm). If vue adds/deletes/updates the holder components, the plugin applies the same changes on the mvms. Since the mvms are totally controlled by the plugin, it is possible to inject some (asynchronized) custom hooks before and after their creation and mounting, which makes it handy to deal with asynchronous data. For example, this plugin injects an "asyncData" hook for every mvm, not only for page components as Nuxt.

To tag a child component as an mvm, we wrap it with a place-holder component "vue-holder" as follows:

```html
<vue-holder name="YourFavoriteName">
  <MyChildComponent />
</vue-holder>
```

To prevent vue from creating the child components and change them to mvms, we need to edit the AST generated by "vue-component-compiler". This is done by the "holdify" function we inject into "vue-loader" (details in [Installation](#Installation)). The child's template will be moved from the default slot to the template attribute. Some other attributes will be added if necessary (details in [Holdify](#Holdify)).

```html
<vue-holder name="YourFavoriteName" template="<YourVueCompoent />">
</vue-holder>
```

Then, the plugin could make a render function for this mvm based on the "template" and some other attributes of the wrapping "vue-holder". It would wait for the code chunk before running the render function if the child component is composed asynchronously. It could also run some asynchronized custom hooks to fetch data or update stores as follows:

```js
<template>
<div>
  <div>Name: {{ name }}</div>
  <div>Recommendations: {{ $store.state.recommendations }} </div>
</div>
</template>
<script>
/** MyChildComponent.vue */
export default {
  async fetch({ $store, $route }) {
    const { data } = await axios.get(`/api/my-recommendations/${$route.params.id}`)
    $store.commit('updateRecommandations', data)
  }

  async asyncData({ $route }) {
    const { data } = await axios.get(`/api/my-data/${$route.params.id}`)
    return { name: data.name }
  }
}
</script>
```


*: [Nuxt](https://nuxtjs.org/api/) patially solves this problem, but only in page components.


# Installation

**npm**

```bash
npm install liyupku2000/vue-component-holder --save
```

**yarn**

```bash
yarn add liyupku2000/vue-component-holder
```

Add the following at webpack.config.js -> module.exports -> modules -> rules -> (vue) -> use -> options:

```js
compilerModules: [{
  postTransformNode: require('vue-compoent-holder/holdify')()
}]
```

Install the plugin (details in [Installation Options](#InstallationOptions)):

```js
import Vue from 'vue'
import VueComponentHolder from 'vue-compoent-holder'

Vue.use(VueComponentHolder, {
  // plugin options
})
```

After installation, you can simply wrap your component in the template as follows:

```html
<vue-holder name="YourFavoriteName">
  <MyChildComponent />
</vue-holder>
```

Please refer the [demo project](https://github.com/liyupku2000/vue-component-holder) for more usage examples.

# Holdify

If the child component is not in "v-for" loop(s), its holdify is pretty straightforward. It only needs to move the child's template from the default slot to the template attribute on the wrapping vue-holder. Within loops, the child component could have multiple mvms and it needs to add some additional attributes on the vue-holder. For example, the "uid" attribute is used to identify different mvms, and the "vars" attribute is for passing local variables to the render function of the mvm. Please try to hodify your components on [Holdify Demo](https://github.com/liyupku2000/vue-component-holder).

# InstallationOptions

**globalHolderMixin**

This option is default to "true". If it is set as "false", you need to setup "HolderMixin" manually in those components which are using "vue-holder" or wrapped by "vue-holder".

```js
/** MyChildComponent.vue */
import { HolderMixin } from 'vue-compoent-holder'
export default {
  mixins: [ HolderMixin /* more mixins*/ ]
}
```

**customHooks**

You could inject asynchronized custom hooks in the parent component. They are partitioned into two groups: "preInitMvms" and "postInitMvms", indicating they are excuted before or after the mvms are initialized.

```js
Vue.use(VueComponentHolder, {
  customHooks: {
    preInitMvms: [ 'beforeInit' ],
    postInitMvms: [ 'inited' ]
  }
})
```

# APIs and Hooks

**$intf**

**$publish**

**holdersUpdated**